## Объясните преимущества и недостатки использования умных указателей (std::unique_ptr, std::shared_ptr, std::weak_ptr) на примере вашего кода.

- std::unique_ptr — умный указатель, владеющий динамически выделенным ресурсом;
- std::shared_ptr — умный указатель, владеющий разделяемым динамически выделенным ресурсом. Несколько std::shared_ptr могут владеть одним и тем же ресурсом, и внутренний счетчик ведет их учет;
- std::weak_ptr — подобен std::shared_ptr, но не увеличивает счетчик.

## Умные указатели в C++ – это классы, которые помогают управлять ресурсами, такими как память, в более безопасном и удобном стиле, чем обычные указатели.

### std::unique_ptr:

**Преимущества:**
- Гарантированная уникальность: Только один std::unique_ptr может владеть объектом в любой момент.
- Автоматическое освобождение памяти: Умный указатель автоматически удаляет объект, когда выходит из области видимости.
- Предотвращение ошибок использования невалидных указателей: Умный указатель не позволит вам использовать его после того, как объект был удален.
**Недостатки:**
- Невозможность совместного владения: Другие объекты не могут получить доступ к ресурсу, на который указывает std::unique_ptr.
- Невозможность копирования: std::unique_ptr нельзя копировать, только перемещать (передавать владение).
```cpp
#include <iostream>
#include <memory>
class MyClass {
public:
    MyClass() { std::cout << "MyClass constructed\n"; }
    ~MyClass() { std::cout << "MyClass destructed\n"; }
};
int main() {
    std::unique_ptr<MyClass> my_object = std::make_unique<MyClass>(); // Создаем уникальный объект
    
    // Используем my_object
    
    // my_object выходит из области видимости, объект уничтожается
    return 0;
}
```


### std::shared_ptr:

**Преимущества:**
- Совместное владение: Несколько std::shared_ptr могут владеть одним объектом, и он будет удален только тогда, когда ни один из указателей не будет ссылаться на него.
- Автоматическое освобождение памяти: Аналогично std::unique_ptr, std::shared_ptr автоматически освобождает память.
- Учет ссылок: Умный указатель отслеживает количество std::shared_ptr, ссылающихся на объект.
**Недостатки:**
- Дополнительные издержки: Управление ссылок и освобождение памяти могут быть менее эффективными, чем в std::unique_ptr.
- Возможные циклические ссылки: Если два std::shared_ptr ссылаются друг на друга, они никогда не будут удалены.
```cpp
#include <iostream>
#include <memory>
class MyClass {
public:
    MyClass() { std::cout << "MyClass constructed\n"; }
    ~MyClass() { std::cout << "MyClass destructed\n"; }
};
int main() {
    std::shared_ptr<MyClass> ptr1 = std::make_shared<MyClass>(); 
    std::shared_ptr<MyClass> ptr2 = ptr1; // ptr2 тоже владеет объектом
    
    // Используем ptr1 и ptr2
    
    // Когда ptr1 и ptr2 выйдут из области видимости, объект будет уничтожен.
    return 0;
}
```

## std::weak_ptr:

**Преимущества:**
- Предотвращение циклических ссылок: std::weak_ptr не увеличивает счетчик ссылок, поэтому он не участвует в циклических зависимостях.
- Слабая ссылка: std::weak_ptr не владеет объектом. Он позволяет вам проверить, существует ли объект, на который он ссылается, и получить std::shared_ptr, если это необходимо.
**Недостатки:**
- Нет автоматического управления памятью: Вы должны вручную управлять освобождением памяти с помощью std::weak_ptr.
- Невозможно использовать напрямую: std::weak_ptr сам по себе не может получить доступ к объекту, для этого необходимо получить std::shared_ptr с помощью метода lock().
```cpp
#include <iostream>
#include <memory>
class MyClass {
public:
    MyClass() { std::cout << "MyClass constructed\n"; }
    ~MyClass() { std::cout << "MyClass destructed\n"; }
};
int main() {
    std::shared_ptr<MyClass> ptr1 = std::make_shared<MyClass>();
    std::weak_ptr<MyClass> weak_ptr = ptr1; // слабая ссылка
    // Используем weak_ptr для проверки существования объекта
    if (auto shared_ptr = weak_ptr.lock()) {
        // Объект существует, используем shared_ptr
    } else {
        // Объект был уничтожен
    }
    return 0;
}
```
